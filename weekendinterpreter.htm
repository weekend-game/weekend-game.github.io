<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html" charset="utf-8">
	<title>
		Weekend game
	</title>
	<link rel="stylesheet" type="text/css" href=styles.css>
</head>

<body>
	<table>
		<tr>
			<td class="title1">Weekend interpreter
			</td>
		</tr>
		<tr>
			<td class="menu">
				<br>
			</td>
		</tr>

		<tr>
			<td class="menu">
				<a class="link" href="index.htm">Home</a>
				|
				<a class="link" href="bankviewer.htm">Bankviewer</a>
				|
				<a class="link" href="weekendtexteditor.htm">Weekend text editor</a>
				|
				Weekend interpreter
				|
				<a class="link" href="aspenforest.htm">Game "Aspen Forest"</a>
				|
				<a class="link" href="weekendcms.htm">CMS</a>
				|
				<a class="link" href="seedkeeper.htm">Seed keeper</a>
				|
				<a class="link" href="weekendwarehouse.htm">Weekend Warehouse</a>
				|
				<a class="link" href="diary.htm">Diary</a>
			</td>
		</tr>

		<tr>
			<td class="menu">
				<br>
				<hr size=1 noshade>
			</td>
		</tr>
	</table>


<!-- Info -->

<table>
	<tr>
		<td class="text">
			<p>
				<b>Java (11)</b>, <b>Swing</b> (Single document interface), <a
					class="link" target="_blank"
					href="https://github.com/weekend-game/weekendtexteditor/">WeekendTextEditor</a>
				is used as an application template.
			</p>
			<p>Creating your own programming language is a useful thing.
				Firstly, it is interesting. Secondly, it can be used, for example,
				for acceptance testing, that is, for writing acceptance tests
				(Robert C. Martin. Agile Software Development: Principles, Patterns,
				Practices. Chapter 4. Testing. "Acceptance tests are programs and
				are therefore executable. However, they are usually written in a
				special scripting language created for customers of the
				application."). Or, for example... Have you tried to write a program
				for calculating wages? Some accruals, deductions, and all this
				depends on a huge number of conditions. Of course, you can take all
				this into account, program it. Or you can give the accountant a
				simple language for describing the calculation rules. The main thing
				is not to tell the accountant the words "programming language", but
				to call it "setting up" accruals and deductions. :-)</p>
			<p>
				So, I took my <a class="link" target="_blank"
					href="https://github.com/weekend-game/weekendtexteditor/">text
					editor</a> and divided its central section into two: the top section
				contained the editor, and the bottom section contained a panel that
				would display everything my interpreter outputs. Then I added a
				"Run" menu with "Run" and "Stop" options. And then I implemented an
				interpreter for my fictional programming language, <b>Weekend
					Game Language</b> (default file extension: <b>WGL</b>), which executes
				the program opened or written in the editor.
			</p>
			<p>
				Eclipse was used for development. The project is located here: <a
					class="link" target="_blank"
					href="https://github.com/weekend-game/weekendinterpreter/">https://github.com/weekend-game/weekendinterpreter/</a>
				(EN) and here: <a class="link" target="_blank"
					href="https://gitflic.ru/project/weekend-game/weekendinterpreter/">https://gitflic.ru/project/weekend-game/weekendinterpreter/</a>
				(RU).
			</p>
		</td>
	<tr>
		<td class="title2">How to run the program</td>
	</tr>
	<tr>
		<td class="text">
			<p>Download the repository to your computer. Everything you need
				for the program is located in the app folder. Navigate to the app
				folder and run the program by double-clicking the
				WeekendInterpreter.jar file or, if the program doesn't start,
				double-click the WeekendInterpreter.bat file. If the program doesn't
				start, download and install Java 11 or later and repeat the steps
				above.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">How to open a project in Eclipse</td>
	</tr>
	<tr>
		<td class="text"><p>In Eclipse, select "Import..." from the
				"File" menu. In the window that opens, select "Existing projects
				into workspace." Navigate to the folder with the downloaded
				repository and click "Finish." The project will open in Eclipse. In
				the Package Explorer (on the left side of the screen), double-click
				the WeekendInterpreter.java file. The file will open for editing (in
				the center of the screen). Run the program by pressing Ctrl+F11 or
				using your preferred method for running programs in Eclipse.</p></td>
	</tr>
	<tr>
		<td id="HowToUse" class="title2">How to use the program</td>
	</tr>
	<tr>
		<td class="text">
			<p>
				At the top of the application window, write a program in a language
				I've named <b>Weekend Game Language</b> (the default file extension
				is <b>WGL</b>). Run it by pressing F5 or clicking the green square
				button in the toolbar, or by selecting "Run" from the "Run" menu. If
				the program gets stuck in a loop, stop it by pressing the Escape key
				or the red square button in the toolbar, or by selecting "Stop" from
				the "Run" menu.
			</p>
		</td>
	</tr>
	<tr>
		<td id="LangDescr" class="title2">Description of the programming
			language Weekend Game Language</td>
	</tr>
	<tr>
		<td class="text">
			<p>Backus-Naur Form (BNF) is convenient for describing language
				syntax. However, the most popular textbooks on various programming
				languages ​​don't use it. Well, I guess I'll do without it, too.</p>
			<p>
				<b>Comment</b>
			</p> <pre class="prog">
REM Program Example</pre>
			<p>
				<b> Variable</b>
			</p>
			<p>A variable in the language is denoted by a letter of the Latin
				alphabet. Thus, 26 variables can be used. Variables have an integer
				type.</p>
			<p>Not very impressive? But you have to understand that this is
				just a taste of interpreter development, knowledge of how it's
				generally done, a template for future adaptation to specific needs,
				the Hello World of interpreter writing.</p>
			<p>
				A <b>string</b> is any sequence of characters enclosed in double
				quotation marks.
			</p>
			<p>
				<b>Assignment, expression</b>
			</p> <pre class="prog">
a = 7
b = 8 * (a + 5)</pre>
			<p>Supported operations: unary minus, +, -, *, /, % (modulo
				remainder), ^ (exponentiation). Operator precedence is traditional,
				but can be changed using parentheses.</p>
			<p>
				<b>Output (to the output area)</b>
			</p> <pre class="prog">
PRINT "a = ", a</pre>
			<p>
				<b>Output with line feed</b>
			</p> <pre class="prog">
PRINTLN
PRINTLN "b = ", b
PRINTLN "b - 37 = ", b – 37</pre>
			<p>That is, after PRINT or PRINTLN, strings, variables, or
				expressions are listed, separated by commas.</p>
			<p>
				<b>Input</b>
			</p> <pre class="prog">
INPUT "Specify the value of X: ", x</pre>
			<p>A value entry box will appear on the screen, asking you to
				enter a value. You can choose not to enter it, but it will be
				interpreted as entering 0. Of course, it would be better to enter
				the value directly in the interpreter's output area. However, this
				complicates the code somewhat, and in this case, it is important
				that the implementation be as simple and easy to read as possible.</p>

			<p>
				<b>Unconditional jump (forgive me, Edsger Wybe Dijkstra)</b>
			</p> <pre class="prog">
GOTO 10</pre>
			<p>
				The number 10 is a program line <b>label</b>. To mark a line and
				thus indicate where to jump, write it at the very beginning of the
				line. For example:
			</p> <pre class="prog">
10 PRINTLN "Label 10"</pre>
			<p>By the way, the label in the GOTO statement doesn't
				necessarily have to be a constant. It can be a variable or any
				expression.</p>
			<p>
				<b> Conditional jump or conditional execution of a single
					command</b>
			</p> <pre class="prog">
IF a > 5 THEN GOTO 20</pre>
			<p>You don't have to write GOTO; you can write any statement, but
				only one.</p>
			<p>The following comparison operators are supported: "&lt;",
				"&gt;" , "=", "#".</p>
			<p>
				<b> Loop</b>
			</p> <pre class="prog">
FOR i = 3 TO 7
   statements
NEXT</pre>
			<p>
				<b>Subroutine</b>
			</p> <pre class="prog">
1000
PRINTLN "This is subroutine 1000"
RETURN</pre>
			<p>Subroutines don't have names; they are identified by labels.
				They should be placed after the main program. A subroutine ends with
				the command</p> <pre class="prog">
RETURN</pre>
			<p>
				<b>Call a subroutine</b>
			</p> <pre class="prog">
GOSUB 1000</pre>
			<p>
				<b>End a program</b>
			</p> <pre class="prog">
END</pre>
			<p>You can leave the end of a program blank, but subroutines may
				follow the main program, in which case you should use END to
				separate them.</p>
			<p>
				<b>Example Program</b>
			</p>
			<p>
				You can see the application of all the above constructs by running
				the <b>CommandsDemo.wgl</b> program (included in the repository).
			</p>
		</td>
	</tr>
	<tr>
		<td id="ProgDescr" class="title2">How the program is written</td>
	</tr>
	<tr>
		<td class="text">
			<p>
				The interpreter is built on a previously created <a class="link"
					target="_blank"
					href="https://github.com/weekend-game/weekendtexteditor">text
					editor</a> as an extension of the text editor, allowing it to execute
				the file being edited, provided that the file contains a program.
				The interpreter is fairly self-contained (game.weekend.interpreter
				package). The editor provides it only with the name of the current
				file and a panel for displaying messages and text output by the
				PRINT language command.
			</p>
			<p>The interpreter is launched using the Runner.run() method.
				This method opens the current editor file and creates an Interpreter
				class object in a separate thread, starting its execution by calling
				the execute() method.</p>
			<p>The Interpreter constructor creates the necessary objects for
				operation, which exist for the entire duration of the interpreter's
				execution.</p>
			<p>The Text class object is a wrapper for the interpreted file.
				It provides methods for conveniently reading program text, but it is
				too low-level for interpretation. The Text class object is used by
				the TokenReader token reader. TokenReader, using Text, reads the
				program and returns the next token. A token is an object of the
				Token class, which can be (type field): a delimiter (DELIMITER), a
				string (STRING), a number (NUMBER), a variable (VARIABLE), or a
				command (COMMAND). Since this object doesn't make any changes to its
				data, I decided to do without get methods. Class variables are
				declared final and cannot be modified. The execute() method reads
				the tokens sequentially. If the token is a command, the method
				responsible for implementing the command is called. All of these
				methods are located in the Command class. If the token is a
				variable, I consider this to be an assignment operator.</p>
			<p>
				<b>Variable</b>
			</p>
			<p>As mentioned in the language description, it supports only 26
				variables, each of which is a letter of the Latin alphabet. The
				Variables class is responsible for working with variables. This
				class contains a 26-element array that stores variable values, and
				two methods for retrieving and assigning a value to a specified
				variable. This is a simple class.</p>
			<p>
				<b>Assignment</b>
			</p>
			<p>So, if the token is a variable, we read the next token and
				expect it to be a delimiter (DELIMITER), specifically the = symbol.
				If it isn't, there's an error. If so, we read the following
				expression using the Expressions.getExp() method. Generally,
				whenever we expect an expression to follow, we call the
				Expressions.getExp() method.</p>
			<p>This method is a bit tricky to understand if you're not
				familiar with the term "recursive descent method." But, simply put,
				we read the next token, store it in the token class variable, read
				the number using the level2() method, return the token to the token
				reader for further reading, and return the read number to the
				calling program.</p>
			<p>Unclear? Complete nonsense? Well, I warned you.</p>
			<p>level2() is responsible for the + and - operations. These are
				the lowest-priority operations. In this method, we read the number
				using level7(). Basically, we read using level3(), but we'll skip
				levels 3, 4, 5, and 6 for clarity. Level7() returns the value from
				the token stored in the token class variable. This must be a number
				or a variable. It will then immediately replace the contents of
				token with the new token.</p>
			<p>Next, we look in the token class variable: is it + or -? If
				so, we read the new token and store it in place of the previously
				read one. We read the second number using level7() and perform + or
				- on the resulting numbers, returning the result. If it wasn't + or
				-, we simply return the value obtained at the lower level.</p>
			<p>level3(), 4, 5, and 6 are methods similar to level2(), but
				they are designed for the operations *, /, %, ^, unary + and -, and
				parentheses. This is the implementation of operator precedence. The
				highest level is a number or variable, followed by parentheses,
				unary + or -, ^, *, /, %, and finally + and -.</p>
			<p>Now I'll describe the command implementation.</p>
			<p>
				<b>REM Command</b>
			</p>
			<p>I command TokenReader to move a line in the file being read by
				calling TokenReader.nextLine(). In other words, I skip everything
				written to the end of the line.</p>
			<p>
				<b>PRINT Command</b>
			</p>
			<p>I read tokens in a loop. If it's a line feed or end of file,
				the loop ends. If it's a string, I output it; otherwise, I try to
				read and evaluate the expression. I output the result. If the next
				token is ';' or ',', I continue the loop; otherwise, I terminate.</p>
			<p>
				<b>PRINTLN Command</b>
			</p>
			<p>This is the same PRINT command, but I output a line feed at
				the end.</p>
			<p>
				<b>INPUT Command</b>
			</p>
			<p>I read the next token. If it's a string, I remember it and
				read the next token. Here, I expect the variable to be read, which
				will store the user's input. Actually, I use
				JOptionPane.showInputDialog() for input. I understand this isn't
				very good, and it would be better to have the input in the output
				panel, but this interpreter is just an exercise in writing
				interpreters, and I decided to keep the program simple.</p>
			<p>
				<b>GOTO Command</b>
			</p>
			<p>I read an expression. I assume that GOTO is followed by a line
				label (a number) where control should be transferred. Using the
				Labels.goToLabel(label) method, I transfer control to the specified
				label. Here, we need to focus on the implementation of labels.</p>
			<p>
				<b>Labels</b>
			</p>
			<p>An object of the Labels class is responsible for working with
				labels. When a Labels object is created, it scans the program text
				and reads the number at the beginning of each line. If one is found,
				the label number and the line number where it was encountered are
				placed in an ArrayList. Clearly, with such a list, it's easy to get
				the line number in the program text corresponding to the label
				number using the label number. And then, using
				TokenReader.setLine(line_number), set the current position for
				further reading of tokens.</p>
			<p>
				<b>IF Command</b>
			</p>
			<p>I read an expression - the left expression. Then I read the
				token and hope to get "&lt;", "&gt;" , "=" or "#". Then I read the
				right expression. I perform the appropriate comparison of the left
				and right expressions, and if the result is TRUE, I read the next
				token. It should be THEN. This should be THEN. If the result is
				FALSE, I move to the next line to read tokens, meaning I continue
				interpretation from the line following the IF. Therefore, the
				command following THEN will not be executed.</p>
			<p>
				<b>FOR Command</b>
			</p>
			<p>I read the token and check if it's a variable. This will be
				the loop variable. Then the '=' token must follow. Then the
				expression - this is the initial value of the loop variable. Then
				the 'TO' token is required. Then I read the expression again - this
				is the final value of the loop variable. If any of this goes wrong,
				it's considered an error. I create a ForItem object, which consists
				of three fields: the name of the loop variable, its final value, and
				the line number of the beginning of the loop body (the line number
				immediately following the FOR command). I push it onto the stack.
				That's all. The stack is needed here to handle nested loops. I
				expect some commands to follow the FOR command - the loop body,
				which will begin to be interpreted now - and then a NEXT command
				will definitely follow, ending the loop.</p>
			<p>
				<b>NEXT Command</b>
			</p>
			<p>I pop the ForItem object from the stack. I increment the loop
				variable by one (yes, in this implementation, the loop variable
				always increments, and only by one). If its value is still less than
				or equal to the final value, I push the ForItem object back onto the
				stack and set the current line to the beginning of the loop body. If
				not, I do nothing. This way, the tokens following NEXT will be
				processed. In other words, I terminate the loop body repetition.</p>
			<p>
				<b>The GOSUB Command</b>
			</p>
			<p>After the GOSUB token, I read an expression. Yes, in this
				implementation, subroutines are identified by numbers, not names.
				Then I remember the line number following the GOSUB command and push
				it onto the subroutine stack (a regular stack). I move to the line
				marked with the specified label (the subroutine number). I expect
				the subroutine to terminate with the RETURN command.</p>
			<p>
				<b>RETURN Command</b>
			</p>
			<p>I read the line number following the GOSUB command from the
				stack, previously pushed there, and set it as the current line for
				further reading by TokenReader. In other words, I terminate the
				subroutine and transfer control for further program execution.</p>
			<p>
				<b>END Command</b>
			</p>
			<p>There is no method corresponding to this token in the Commands
				class. If this token is encountered, the interpreter simply
				terminates.</p>
			<p>You can learn more about the program's operation by
				downloading the project, opening it in Eclipse, reading the class
				code, making changes, running the program, and watching the results.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">Results</td>
	</tr>
	<tr>
		<td class="text">
			<p>An interpreter has been created for a language similar to
				either Fortran or the very old Basic used by our fathers,
				grandmothers, and some of us. It's interesting as a test version of
				an interpreter. It could be useful as a template for adapting it to
				specific needs.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">It would be nice...</td>
	</tr>
	<tr>
		<td class="text">
			<p>It would be nice to add line numbers in the editor and
				highlight keywords in color.</p>
		</td>
	</tr>
</table>

<!-- End of info -->
	<table>
		<tr>
			<td class="menu">
				<hr size=1 noshade>
				<br>
			</td>
		</tr>

		<tr>
			<td class="menu">
				<a class="link" href="index.htm">Home</a>
				|
				<a class="link" href="bankviewer.htm">Bankviewer</a>
				|
				<a class="link" href="weekendtexteditor.htm">Weekend text editor</a>
				|
				Weekend interpreter
				|
				<a class="link" href="aspenforest.htm">Game "Aspen Forest"</a>
				|
				<a class="link" href="weekendcms.htm">CMS</a>
				|
				<a class="link" href="seedkeeper.htm">Seed keeper</a>
				|
				<a class="link" href="weekendwarehouse.htm">Weekend Warehouse</a>
				|
				<a class="link" href="diary.htm">Diary</a>
			</td>
		</tr>

		<tr>
			<td class="menu">
				<br>
See my projects at <a class="link" href="https://github.com/weekend-game">https://github.com/weekend-game</a>
(EN) or <a class="link" href="https://gitflic.ru/user/weekend-game">https://gitflic.ru/user/weekend-game</a> (RU).<br>
Please write to me at <a class="link" href="mailto:weekend_game@mail.ru">weekend_game@mail.ru</a><br>
			</td>
		</tr>
	</table>
	<br>

<!-- Generated with WeekendCMS. See more: https://github.com/weekend-game/weekendcms -->

</body>

</html>
