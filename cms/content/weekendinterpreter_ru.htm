
<!-- Info -->

<table width="80%" align=center border=0 cellpadding=0 cellspacing=0>
	<tr>
		<td class="text">
			<p>
				<b> Java</b>, <b>Swing</b> (Single document interface), в качестве
				шаблона приложения (<a
					href="https://gitflic.ru/project/weekend-game/weekendtexteditor">WeekendTextEditor</a>)
			</p>
			<p>Наращиваю сложность. Вообще-то, программисту со сложностью
				надо бороться (Стив Макконел. Совершенный код. Глава 34. Основы
				мастерства), но это справедливо для текстов программ. А я наращиваю
				сложность задачи.</p>
			<p>Создание своего языка программирования — полезное дело.
				Во-первых, это интересно. Во-вторых, его можно использовать,
				например, для приёмочного тестирования, то есть для написания
				приёмочных тестов (Роберт Мартин. Быстрая разработка программ. Глава
				4 Тестирование. Приемочные тесты. "Обычно тесты разрабатываются с
				помощью специального языка подготовки сценариев, разрабатываемого
				для заказчиков приложения."). Или, например… Вы пытались написать
				программу расчёта заработной платы? Какие-то начисления, удержания,
				причём все они зависят от огромного количества условий. Можно,
				конечно, всё это учесть, запрограммировать. А можно дать бухгалтеру
				простой язык для описания правил расчётов. Главное — не говорить
				бухгалтеру слов "язык программирования", а называть это "настройка"
				начислений и удержаний. :)</p>
			<p>
				Итак, я беру свой текстовый редактор и делю его центральную часть на
				две: в верхней части оставляю редактор, а в нижней размещаю панель,
				в которой будет отображаться всё, что будет выводить мой
				интерпретатор. Затем добавляю меню "Выполнить" с пунктами
				"Выполнить" и "Остановить". Реализую интерпретатор придуманного
				языка прораммирования <b>Weekend Game Language</b> (расширение
				файлов по умолчанию - <b>WGL</b>), выполняющий программу,
				открытую/написанную в редакторе.
			</p>
			<p>
				Для разработки использован Eclipse. Проект расположен здесь: <a
					class="link" target="_blank"
					href="https://github.com/weekend-game/weekendinterpreter/">https://github.com/weekend-game/weekendinterpreter/</a>
				(EN) и здесь: <a class="link" target="_blank"
					href="https://gitflic.ru/project/weekend-game/weekendinterpreter/">https://gitflic.ru/project/weekend-game/weekendinterpreter/</a>
				(RU).
			</p>
		</td>
	</tr>
	<tr>
		<td class="title2">Как запустить программу</td>
	</tr>
	<tr>
		<td class="text">
			<p>Скачайте репозиторий на свой компьютер. Всё необходимое для
				работы программы расположено в папке app. Зайдите в папку app и
				запустите программу двойным кликом по WeekendInterpreter.jar или,
				если он не запускается, двойным кликом по WeekendInterpreter.bat.
				Если и последнее не запускает приложение, то скачайте и установите
				Java 11 или новее и снова попробуйте способы, описанные выше.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">Как открыть проект в Eclipse</td>
	</tr>
	<tr>
		<td class="text"><p>В Eclipse, в меню выберите File –
				Import... В появившемся окне выберите Existing Projects into
				Workspace. Укажите папку скаченного вами репозитория и нажмите
				кнопку Finish. Проект откроется в Eclipse. В Package Explorer (в
				левой части экрана) дважды кликните на файле
				WeekendInterpreter.java. Файл откроется для редактирования (в
				центральной части экрана). Запустите программу на выполнение, нажав
				Ctrl+F11 или так, как Вам удобно запускать программы в Eclipse.</p></td>
	</tr>
	<tr>
		<td class="title2">Как работать с программой</td>
	</tr>
	<tr>
		<td class="text">
			<p>
				В верхней части окна приложения пишем программу на языке, который я
				назвал <b>Weekend Game Language</b> (расширение файлов по умолчанию
				- <b>WGL</b>). Запускаем на выполнение клавишей F5 или кнопкой с
				зелёным квадратом на инструментальной линейке, или выбрав из меню
				"Выполнить" пункт "Выполнить". Если программа зациклилась, то, чтобы
				остановить её, нажимаем клавишу Escape или кнопку с красным
				квадратом на инструментальной линейке, или выбираем из меню
				"Выполнить" пункт "Остановить".
			</p>
		</td>
	</tr>
	<tr>
		<td id="LangDescr" class="title2">Описание языка программирования
			Weekend Game Language</td>
	</tr>
	<tr>
		<td class="text">
			<p>Для описания синтаксиса языка удобно использовать Форму
				Бэкуса-Наура (BNF). Однако наиболее популярные учебники по различным
				языкам программирования её не используют. Что ж, пожалуй, и я без
				неё обойдусь.</p>
			<p>
				<b>Комментарий</b>
			</p> <pre class="prog">
REM Пример программы</pre>
			<p>
				<b>Переменная</b>
			</p>
			<p>Переменная в языке обозначается буквой латинского алфавита.
				Таким образом, можно использовать 26 переменных. Переменные имеют
				целый тип.</p>
			<p>Не очень впечатляет? Но надо понимать, что это только проба
				разработки интерпретатора, знание того, как это вообще делается,
				заготовка для будущей адаптации под конкретные нужды, Hello world в
				написании интерпретаторов.</p>
			<p>
				<b>Строка</b> это любая последовательность символов, заключённая в
				двойные кавычки.
			</p>
			<p>
				<b>Присваивание, выражение</b>
			</p> <pre class="prog">
a = 7
b = 8 * (a + 5)</pre>
			<p>Поддерживаются операции: унарный минус, +, -, *, /, % (остаток
				по модулю), ^ (возведение в степень). Приоритет операций
				традиционный, но можно изменять круглыми скобками.</p>
			<p>
				<b>Вывод (в область вывода)</b>
			</p> <pre class="prog">
PRINT "a = ", a</pre>
			<p>
				<b>Вывод с переводом строки</b>
			</p> <pre class="prog">
PRINTLN
PRINTLN "b = ", b
PRINTLN "b - 37 = ", b – 37</pre>

			<p>Т.е. после PRINT или PRINTLN перечисляются через запятую
				строки, переменные или выражения.
			<p>
			<p>
				<b>Ввод</b>
			</p> <pre class="prog">
INPUT "Укажите значение X: ", x</pre>
			<p>На экране появится окно ввода значения, и надо будет ввести
				значение. Можно не вводить, но это будет интерпретироваться как ввод
				0. Конечно хорошо бы вводить значение непосредственно в области
				вывода интерпретатора. Но это несколько усложняет код, а в данном
				случае важно, чтобы реализация была максимально простой и легко
				читалась.</p>
			<p>
				<b>Безусловный переход (да простит меня Эдсгер Вибе Дейкстра)</b>
			</p> <pre class="prog">
GOTO 10</pre>
			<p>
				Число 10 — это <b>метка</b> строки программы. Чтобы поставить в
				строке метку и таким образом указать, куда следует переходить,
				напишите это число в самом начале строки. Например:
			</p> <pre class="prog">
10 PRINTLN "Метка 10"</pre>
			<p>Кстати, в операторе GOTO в качестве метки не обязательно
				использовать константу. Это может быть переменная или произвольное
				выражение.</p>
			<p>
				<b>Условный переход или выполнение одной команды по условию</b>
			</p> <pre class="prog">
IF a > 5 THEN GOTO 20 </pre>
			<p>Не обязательно писать GOTO, можно написать любой оператор, но
				только один.</p>
			<p>Поддерживаются операции сравнения: &lt;, &gt;, =, #.</p>
			<p>
				<b>Цикл</b>
			</p> <pre class="prog">
FOR i = 3 TO 7
  операторы
NEXT</pre>
			<p>
				<b>Подпрограмма</b>
			</p> <pre class="prog">
1000 
PRINTLN "Это подпрограмма 1000"
RETURN</pre>
			<p>У подпрограмм нет имён. Они идентифицируются метками.
				Располагать их следует после основной программы. Заканчиваеся
				подпрограмма командой</p> <pre class="prog">
RETURN</pre>
			<p>
				<b>Вызов подпрограммы</b>
			</p> <pre class="prog">
GOSUB 1000</pre>
			<p>
				<b>Завершение программы</b>
			</p> <pre class="prog">
END</pre>
			<p>В конце программы можно вообще ничего не писать, но после
				текста основной программы могут следовать подпрограммы, и тогда надо
				использовать END, чтобы их разделить.</p>
			<p>
				<b>Пример программы</b>
			</p>
			<p>
				Применение всех вышеописанных конструкций можно посмотреть, запустив
				программу <b>CommandsDemo.wgl</b> (включена в репозиторий).
			</p>
		</td>
	</tr>
	<tr>
		<td id="ProgDescr" class="title2">Как программа написана</td>
	</tr>
	<tr>
		<td class="text">
			<p>
				Интерпретатор сделан на основе ранее созданного <a
					href="https://gitflic.ru/project/weekend-game/weekendtexteditor">текстового
					редактора</a>, как расширение текстового редактора возможностью
				запустить на выполнение редактируемый файл, если, конечно, файл
				содержит программу. Интерпретатор является довольно самостоятельным
				(пакет game.weekend.interpreter). Редактор предоставляет ему только
				имя текущего файла и панель для отображения сообщений и текста,
				выводимого командой языка PRINT.
			</p>
			<p>Запуск интерпретатора осуществляется методом Runner.run().
				Этот метод открывает текущий файл редактора и в отдельном потоке
				создаёт объект класса Interpreter, запуская его работу вызовом
				метода execute().</p>
			<p>В конструкторе Interpreter создаются необходимые для работы
				объекты, существующие в течение всего времени работы интерпретатора.
			</p>
			<p>Объект класса Text - это оболочка для интерпретируемого файла.
				Он предоставляет методы для удобного чтения текста программы, но это
				слишком низкий уровень для интерпретации. Объект класса Text
				используется читателем лексем TokenReader. TokenReader, используя
				Text, читает программу и возвращает очередную лексему. Лексема - это
				объект класса Token, который может быть (поле type): разделителем
				(DELIMITER), строкой (STRING), числом (NUMBER), переменной
				(VARIABLE), командой (COMMAND). Поскольку никаких изменений этот
				объект не производит со своими данными, я решил обойтись и без
				методов get. Переменные класса объявлены финальными, и изменить их
				нельзя. В методе execute() происходит последовательное чтение
				лексем. Если лексема - команда, то вызывается метод, отвечающий за
				реализацию команды. Все они находятся в классе Command. Если лексема
				- переменная, то считаю, что это оператор присваивания.</p>
			<p>
				<b>Переменная</b>
			</p>
			<p>Как говорилось в описании языка, он поддерживает использование
				только 26 переменных, и переменная - это буква латинского алфавита.
				За работу с переменными отвечает класс Variables. Класс содержит
				массив из 26 элементов, где хранит значения переменных, и два метода
				для получения значения и присвоения значения указанной переменной.
				Вот такой простой класс.</p>
			<p>
				<b>Присваивание</b>
			</p>
			<p>Итак, если лексема - переменная, то читаем следующую лексему и
				ожидаем, что это разделитель (DELIMITER), а именно символ =. Если
				это не так, то ошибка. Если так, то читаем следующее за ним
				выражение методом Expressions.getExp(). Вообще, всякий раз, когда мы
				ожидаем, что далее идёт выражение, мы будем вызывать метод
				Expressions.getExp().</p>
			<p>Этот метод немного сложен для понимания, если вы не знакомы с
				термином «метод рекурсивного спуска». Но, говоря по-простому, мы
				читаем очередную лексему, запоминаем её в переменной класса token,
				читаем число методом level2(), возвращаем лексему в читатель лексем
				для последующего чтения и возвращаем прочитанное число в вызывающую
				программу.</p>
			<p>Ничего не понятно? Полный бред? Ну, я предупреждал.</p>
			<p>level2() отвечает за операции + и -. Это самые
				низкоприоритетные операции. В этом методе читаем число посредством
				level7(). Вообще-то, читаем посредством level3(), но пропустим
				уровни 3, 4, 5 и 6 для облегчения понимания. Level7() вернет
				значение из лексемы, сохраненной в переменной класса token. Это
				обязательно должно быть число или переменная. И тут же заменит
				содержимое token на новую лексему.</p>
			<p>Далее смотрим в переменной класса token: это не + ли или - ли?
				Если так, то читаем новую лексему и запоминаем её на месте ранее
				прочитанной. Читаем второе число методом level7() и выполняем + или
				- с полученными числами и возвращаем результат. Если это не был +
				или -, то просто вернем значение, которое было получено на более
				низком уровне.</p>
			<p>level3(), 4, 5 и 6 - это методы, аналогичные level2(), но
				предназначенные для операций *, /, %, ^, унарных + и -, скобок. То
				есть это реализация приоритета вычисления операций. Высший уровень -
				это число или переменная, далее круглые скобки, унарные + или -, ^,
				*, /, % и, наконец, + и -.</p>
			<p>Теперь опишу реализацию команд.</p>
			<p>
				<b>Команда REM</b>
			</p>
			<p>Даю команду TokenReader-у перевести строку в читаемом файле
				вызовом TokenReader.nextLine(). Другими словами, пропускаю всё, что
				написано до конца строки.</p>
			<p>
				<b>Команда PRINT</b>
			</p>
			<p>В цикле читаю лексемы. Если это перевод строки или конец
				файла, то цикл заканчивается. Если это строка, то вывожу эту строку,
				иначе пытаюсь прочитать и вычислить выражение. Результат вывожу.
				Если следующая лексема - это ';' или ',', то продолжаю цикл, а иначе
				заканчиваю работу.</p>
			<p>
				<b>Команда PRINTLN</b>
			</p>
			<p>Это та же самая команда PRINT, но в конце вывожу перевод
				строки.</p>
			<p>
				<b>Команда INPUT</b>
			</p>
			<p>Читаю следующую лексему. Если это строка, то запоминаю её и
				читаю следующую лексему. Тут я ожидаю, что прочитана переменная,
				куда будет помещен результат ввода пользователя. Собственно, для
				ввода я использую JOptionPane.showInputDialog(). Понимаю, что это не
				очень хорошо, и было бы лучше сделать ввод в панели вывода, но этот
				интерпретатор - только упражнение в написании интерпретаторов, и я
				решил не усложнять программу.</p>
			<p>
				<b>Команда GOTO</b>
			</p>
			<p>Читаю выражение. Подразумеваю, что за GOTO следует метка
				строки (число), куда следует передать управление. Методом
				Labels.goToLabel(метка) передаю управление на указанную метку. Тут
				следует отвлечься на реализацию меток.</p>
			<p>
				<b>Метки</b>
			</p>
			<p>За работу с метками отвечает объект класса Labels. При
				создании объекта Labels он сканирует текст программы и читает число
				в начале каждой строки. Если такое обнаруживается, то в ArrayList
				помещается номер метки и номер строки, где она встретилась. Понятно,
				что имея такой список, легко по номеру метки получить номер строки в
				тексте программы, ей соответствующей. И затем, используя
				TokenReader.setLine(номер_строки), установить текущую позицию для
				дальнейшего чтения лексем.</p>
			<p>
				<b>Команда IF</b>
			</p>
			<p>Читаю выражение - левое выражение. Затем читаю лексему и
				надеюсь получить "&lt;", "&gt;" , "=" или "#". Затем читаю правое
				выражение. Делаю соответствующее сравнение левого и правого
				выражения, и если результат ИСТИНА, то читаю следующую лексему. Она
				должна быть THEN. Это должно быть THEN. Если результат ЛОЖЬ, я
				перехожу на следующую строку для считывания лексем, то есть
				продолжаю интерпретацию со строки, следующей за IF. Таким образом,
				команда, следующая за THEN, не будет выполнена.
			<p>
				<b>Команда FOR</b>
			</p>
			<p>Читаю лексему и проверяю, переменная ли это. Это будет
				переменная цикла. Затем должна следовать лексема '=' . Затем
				выражение - это начальное значение переменной цикла. Затем
				обязательна лексема 'TO' . Затем опять читаю выражение - это
				финальное значение переменной цикла. Если что-то из этого пошло не
				так, то это считается ошибкой. Создаю объект ForItem, который
				состоит из трех полей: имя переменной цикла, её конечное значение,
				номер строки начала тела цикла (номер строки, следующей сразу за
				командой FOR), и помещаю его в стек. На этом всё. Стек тут нужен для
				обработки вложенных циклов. Я ожидаю, что после команды FOR
				последуют какие-то команды - тело цикла, которые и начнут
				интерпретироваться сейчас, и затем обязательно последует команда
				NEXT - завершение цикла.
			<p>
				<b>Команда NEXT</b>
			</p>
			<p>Извлекаю из стека объект ForItem. Увеличиваю переменную цикла
				на единицу (да, в данной реализации переменная цикла всегда только
				увеличивается и всегда только на единицу). Если её значение всё ещё
				меньше или равно финальному значению, то опять помещаю в стек объект
				ForItem и ставлю текущей строкой строку начала тела цикла. Если нет,
				то ничего не делаю. И таким образом, далее будут обрабатываться
				лексемы, следующие за NEXT. Иначе говоря, я завершаю повторение тела
				цикла.</p>
			<p>
				<b>Команда GOSUB</b>
			</p>
			<p>После лексемы GOSUB читаю выражение. Да, в данной реализации
				подпрограммы идентифицируются не именами, а номерами. Затем
				запоминаю номер строки, следующей командой GOSUB, и помещаю её в
				стеке подпрограмм (самый обычный стек). Перехожу на строку,
				отмеченную указанной меткой (номером подпрограммы). Я ожидаю, что
				подпрограмма будет закончена командой RETURN.</p>
			<p>
				<b>Команда RETURN</b>
			</p>
			<p>Читаю из стека ранее помещенный туда номер строки, следующей
				за командой GOSUB, и ставлю её текущей для дальнейшего чтения
				TokenReader. Иначе говоря, я завершаю выполнение подпрограммы и
				передаю управление для дальнейшего выполнения программы.</p>
			<p>
				<b>Команда END</b>
			</p>
			<p>Метода, соответствующего этой лексеме, в классе Commands нет.
				Если встречается эта лексема, то интерпретатор просто завершает
				работу.</p>
			<p>На этом всё. Ну а более подробно о работе программы можно
				узнать, если скачать проект, открыть его в Eclipse, почитать тексты
				классов, что-нибудь менять, запускать программу и смотреть, что из
				этого получается.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">Итоги</td>
	</tr>
	<tr>
		<td class="text">
			<p>Сделана реализация вот такого языка, похожего то ли на
				Fortran, то ли на доисторический Basic, на которых писали наши папы,
				бабушки и некоторые из нас. Как проба написания интерпретатора - это
				интересно. Может пригодиться как заготовка для адаптации под
				конкретные нужды.</p>
		</td>
	</tr>
	<tr>
		<td class="title2">Хорошо бы…</td>
	</tr>
	<tr>
		<td class="text">
			<p>Сделать нумерацию строк в редакторе и выделение цветом
				ключевых слов.</p>
		</td>
	</tr>
</table>

<!-- End of info -->
